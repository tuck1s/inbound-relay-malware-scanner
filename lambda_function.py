import json, email, requests, os, time
from email import policy

# read config from env vars, where present
def getConfig():
    return {
        'sparkpost_host': os.getenv('SPARKPOST_HOST', 'https://api.sparkpost.com'),
        'sparkpost_api_key': os.getenv('SPARKPOST_API_KEY'),
        'attachmentscanner_api_key': os.getenv('ATTACHMENTSCANNER_API_KEY'),
        'from_email': os.getenv('FROM_EMAIL')
    }

# start scan with payload p, appending the unique ID to the scanResource list
def startScan(fname, p, cfg):
    headers = {
        'accept': 'application/json',
        'authorization': 'bearer '+cfg['attachmentscanner_api_key']
    }
    res = requests.post('https://beta.attachmentscanner.com/requests', headers=headers, files= {'file': (fname, p)})
    if res.status_code == 200:
        return res
    else:
        print('Unexpected return code', res.status_code)
        exit(1)

def scanResults(r, cfg):
    headers = {
        'accept': 'application/json',
        'authorization': 'bearer ' + cfg['attachmentscanner_api_key']
    }
    res = requests.get('https://beta.attachmentscanner.com/requests/'+r, headers=headers)
    if res.status_code == 200:
        return res
    else:
        print('Unexpected return code', res.status_code)
        exit(1)

# Handle SparkPost Inbound Relay Webhook carrying one or more messages
# TODO: check Authorisation in SparkPost inbound relay webhook
def lambda_handler(event, context):
    # Collect config
    cfg = getConfig()

    for i in event:
        m = i['msys']['relay_message']
        print('From:', m['msg_from'])
        print('To:', m['rcpt_to'])
        c= m['content']
        print('Subject:', c['subject'])
        body = c['email_rfc822']
        msg = email.message_from_string(body, policy=policy.default)

        pendingScans = []
        scanVerdict = {
            'ok': 0,
            'bad': 0,
        }
        for part in msg.walk():
            # multipart/* are just containers
            if part.get_content_maintype() == 'multipart':
                continue
            ct = part.get_content_type()
            if ct == 'text/plain' or ct == 'text/html':
                pass
            else:
                p = part.get_payload(decode=True)
                fname = part.get_filename()
                if fname:
                    print('Attachment: {}, {} bytes'.format(fname, len(p)))
                res = startScan(fname, p, cfg)
                verdict = res.json()['status']
                if verdict == 'ok':
                    scanVerdict['ok'] += 1
                elif verdict == 'found':
                    scanVerdict['bad'] += 1
                elif verdict == 'pending':
                    pendingScans.append(res.json()['id'])
                elif verdict == 'failed':
                    print('Scan failed', res.text())
        # Now collect in the pending results which take some time to appear
        while(len(pendingScans) > 0):
            time.sleep(0.4)
            for j in range(0, len(pendingScans)):
                res = scanResults(pendingScans[j], cfg)
                verdict = res.json()['status']
                if verdict == 'ok':
                    scanVerdict['ok'] += 1
                    del pendingScans[j]
                elif verdict == 'found':
                    scanVerdict['bad'] += 1
                    del pendingScans[j]
                elif verdict == 'pending':
                    pass
                elif verdict == 'failed':
                    print('Scan failed', res.text())
        # All results now in
        print('Scans OK: {}, Bad: {}'.format(scanVerdict['ok'], scanVerdict['bad']))
        if scanVerdict['bad'] > 0:
            print('Verdict: reject')
        else:
            print('Verdict: accept')
    return 'Done'

#
# Test code
with open('rq.json') as f:
    body = json.loads(f.read())
    print(lambda_handler(body, None))